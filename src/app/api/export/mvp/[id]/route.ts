import JSZip from "jszip";
import { NextResponse } from "next/server";
import PDFDocument from "pdfkit";
import path from "path";
import { getMVPOutput } from "@/lib/mvp/outputs";
import { getAgentSession } from "@/lib/agents/sessions";

function buildMarkdown(output: { title: string | null; summary: string | null; stack: string | null; pricing: string | null; risk: string | null; validation_score: number | null }) {
  return [
    `# ${output.title ?? "MVP Blueprint"}`,
    "",
    "## Summary",
    output.summary ?? "No summary available.",
    "",
    "## Recommended Stack",
    output.stack ?? "Not specified",
    "",
    "## Pricing Strategy",
    output.pricing ?? "Not specified",
    "",
    "## Key Risks",
    output.risk ?? "Not specified",
    "",
    `Validation Score: ${(output.validation_score ?? 0) * 100}%`,
    "",
  ].join("\n");
}

async function buildValidationPdf(options: {
  title: string | null;
  summary: string | null;
  validationScore: number | null;
  highlights: string[];
}) {
  return new Promise<Buffer>((resolve, reject) => {
    const fontPath = path.join(process.cwd(), "fonts", "NotoSans-Regular.ttf");

    // Create PDF with custom font at initialization to avoid Helvetica.afm
    const doc = new PDFDocument({ size: "A4", margin: 48, font: fontPath });
    const chunks: Buffer[] = [];

    doc.on("data", (chunk) => chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)));
    doc.on("error", (error) => reject(error));
    doc.on("end", () => resolve(Buffer.concat(chunks)));

    // We'll track the active font name for reuse
    let bodyFont = "Times-Roman";
    try {
      doc.registerFont("rw-regular", fontPath);
      doc.font("rw-regular");
      bodyFont = "rw-regular";
      console.log("âœ… PDF font loaded successfully");
    } catch (error) {
      console.warn(
        "[export.mvp] Failed to load custom font, falling back to Times-Roman",
        error instanceof Error ? error.message : error
      );
      doc.font("Times-Roman");
    }

    // --- PDF content layout ---
    doc.fillColor("#0f1117").fontSize(22).font(bodyFont)
      .text("Realwebwins MVP Validation Report", { align: "left" });
    doc.moveDown();

    doc.fillColor("#333333").fontSize(12).font(bodyFont);
    doc.text(`Generated: ${new Date().toLocaleString()}`);
    doc.text(`Validation Score: ${(options.validationScore ?? 0) * 100}%`);
    doc.moveDown();

    doc.font(bodyFont).fontSize(14).fillColor("#0f1117")
      .text(options.title ?? "Untitled MVP");
    doc.moveDown(0.5);
    doc.font(bodyFont).fontSize(12).fillColor("#333333")
      .text(options.summary ?? "No summary available.", { align: "left" });
    doc.moveDown();

    if (options.highlights.length > 0) {
      doc.font(bodyFont).fillColor("#0f1117").text("Highlights");
      doc.moveDown(0.5);
      doc.fillColor("#333333").font(bodyFont).fontSize(12);
      options.highlights.forEach((item, index) => {
        doc.text(`${index + 1}. ${item}`);
      });
      doc.moveDown();
    }

    doc.font(bodyFont).fillColor("#555555").text(
      "This report was auto-generated by the Realwebwins agent studio to summarize validation insights.",
      { align: "left" }
    );

    doc.end();
  });
}


export async function GET(
  _request: Request,
  context: { params: { id: string } }
) {
  const { id } = context.params;

  try {
    const output = await getMVPOutput(id);
    if (!output) {
      return NextResponse.json(
        { success: false, error: "MVP_NOT_FOUND", message: "MVP output not found." },
        { status: 404 }
      );
    }

    const session = await getAgentSession(output.session_id);
    const zip = new JSZip();

    zip.file("MVP.md", buildMarkdown(output));
    const transcriptHighlights = (session.transcript ?? [])
      .filter((message) => message.role === "assistant")
      .slice(0, 3)
      .map((message) => `${message.agent.replace(/_/g, " ")}: ${message.content}`);

    const pdfBuffer = await buildValidationPdf({
      title: output.title,
      summary: output.summary,
      validationScore: output.validation_score,
      highlights: transcriptHighlights,
    });

    zip.file("validation.pdf", pdfBuffer);
    zip.file(
      "conversation.json",
      JSON.stringify(
        {
          session_id: session.id,
          status: session.status,
          transcript: session.transcript,
        },
        null,
        2
      )
    );

    const buffer = await zip.generateAsync({ type: "nodebuffer" });

    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": `attachment; filename="mvp-${output.id}.zip"`,
      },
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error("[export.mvp]", message);
    const status = message.includes("not found") ? 404 : 500;
    return NextResponse.json(
      { success: false, error: status === 404 ? "MVP_NOT_FOUND" : "EXPORT_FAILED", message },
      { status }
    );
  }
}
